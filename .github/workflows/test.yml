name: Test Build

on:
  push:
    branches:
      - main
    paths:
      - '**'
      # - '!**/assets/**'
      # - '!**.md'
      - '!**/ISSUE_TEMPLATE/**'
      - '!**/modules/web/**'
  pull_request:
    paths-ignore:
      - '**/modules/web/**'
  workflow_run:
    workflows: [Build Web]
    branches: [master]
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:

  prepare:
    runs-on: ubuntu-latest
    if: ${{ !startsWith(github.event.head_commit.message, 'Merge pull request') }}
    outputs:
      # versionL: 完整版本号，例如 3.26.3-beta.1
      versionL: ${{ steps.set-ver.outputs.full_version_name }}
      # version: 基础版本号，例如 3.26.3
      version: ${{ steps.set-ver.outputs.current_version }}
      # build_number: 增量构建号，例如 1
      build_number: ${{ steps.set-ver.outputs.build_number }}
      # latest_tag: 最近一个用于版本递增的 tag，例如 v3.26.2-beta.5
      latest_tag: ${{ steps.set-ver.outputs.last_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          # 确保拉取所有标签，用于版本号计算
          fetch-depth: 0

      - name: 计算版本号和构建号
        id: set-ver
        run: |
          # 1. 读取 version.properties 文件获取基础版本号
          MAJOR=$(grep 'VERSION_MAJOR' version.properties | cut -d'=' -f2)
          MINOR=$(grep 'VERSION_MINOR' version.properties | cut -d'=' -f2)
          PATCH=$(grep 'VERSION_PATCH' version.properties | cut -d'=' -f2)
          CURRENT_VERSION="$MAJOR.$MINOR.$PATCH"
          
          # 2. 尝试获取最近一次成功的构建号 (beta build number)
          # 查找最近的、格式为 vX.Y.Z-beta.N 的标签，且 X.Y.Z 部分与当前版本匹配
          # 只有在推送到 main 分支时才进行自增计算
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
              LAST_TAG=$(git tag --list "v*.*.*-beta.*" --sort=-committerdate | head -n 1)
          
              # 查找匹配当前 CURRENT_VERSION 的上一个 TAG
              LAST_MATCHING_TAG=$(git tag --list "v$CURRENT_VERSION-beta.*" --sort=-committerdate | head -n 1)
          
              if [[ $LAST_MATCHING_TAG =~ v[0-9]+\.[0-9]+\.[0-9]+-beta\.([0-9]+) ]]; then
                # 如果找到匹配当前 PATCH 版本的 beta 标签，则递增
                LAST_BUILD_NUM="${BASH_REMATCH[1]}"
                NEW_BUILD_NUM=$((LAST_BUILD_NUM + 1))
                LAST_TAG_FOR_LOG="$LAST_MATCHING_TAG"
                echo "版本 $CURRENT_VERSION 未变更，构建号自增：$LAST_BUILD_NUM -> $NEW_BUILD_NUM"
              else
                # 如果找不到匹配的标签 (可能是 PATCH 刚修改，或首次构建)，则重置为 1
                NEW_BUILD_NUM=1
                # 如果是 PATCH 首次构建，则使用仓库中最近的那个 tag 作为日志起点
                LAST_TAG_FOR_LOG="$LAST_TAG"
                echo "版本 $CURRENT_VERSION 为新版本或首次构建，构建号重置为 $NEW_BUILD_NUM"
              fi
          else
              # 对于 PR 或其他分支，使用一个固定的构建号 0
              NEW_BUILD_NUM=0
              LAST_TAG_FOR_LOG=$(git tag --sort=-committerdate | head -n 1)
              echo "非 main 分支推送，构建号设置为 $NEW_BUILD_NUM"
          fi
          
          # 3. 构造最终版本信息
          VERSION_SUFFIX_NAME="-beta.$NEW_BUILD_NUM"
          FULL_VERSION_NAME="${CURRENT_VERSION}${VERSION_SUFFIX_NAME}"
          
          # 4. 设置输出供后续作业使用
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "full_version_name=$FULL_VERSION_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$NEW_BUILD_NUM" >> $GITHUB_OUTPUT
          echo "last_tag=$LAST_TAG_FOR_LOG" >> $GITHUB_OUTPUT

  build:
    needs: prepare
    strategy:
      matrix:
        product: [ app ]
        type: [ release ]
      fail-fast: false
    runs-on: ubuntu-latest
    env:
      product: ${{ matrix.product }}
      type: ${{ matrix.type }}
      # 使用 prepare job 的输出
      VERSION: ${{ needs.prepare.outputs.version }}
      VERSIONL: ${{ needs.prepare.outputs.versionL }}
      BUILD_NUMBER: ${{ needs.prepare.outputs.build_number }}
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Set up JDK 17
        uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: 17
      - name: Clear 18PlusList.txt
        run: |
          echo "清空18PlusList.txt"
          echo "">$GITHUB_WORKSPACE/app/src/main/assets/18PlusList.txt
      - name: Release Apk Sign
        run: |
          echo "${{ secrets.SIGNING_KEY }}" | base64 -d > $GITHUB_WORKSPACE/app/my-release-key.jks
          echo "RELEASE_STORE_FILE=my-release-key.jks" >> $GITHUB_WORKSPACE/gradle.properties
          echo "RELEASE_STORE_PASSWORD=${{ secrets.KEYSTORE_PASSWORD }}" >> $GITHUB_WORKSPACE/gradle.properties
          echo "RELEASE_KEY_ALIAS=${{ secrets.KEY_ALIAS }}" >> $GITHUB_WORKSPACE/gradle.properties
          echo "RELEASE_KEY_PASSWORD=${{ secrets.KEY_PASSWORD }}" >> $GITHUB_WORKSPACE/gradle.properties

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: 统一版本号
        run: |
          # 1. 临时修改 version.properties 中的 VERSION_SUFFIX，供 build.gradle 读取 versionName
          echo "VERSION_SUFFIX=-beta.${{ env.BUILD_NUMBER }}" >> $GITHUB_WORKSPACE/version.properties
          
          # 2. 覆盖 build.gradle 中复杂的 versionCode 计算逻辑
          # 将 versionCode 设为 10000 + BUILD_NUMBER，忽略 gitCommits
          # 替换 app/build.gradle 中 versionCode 所在行
          sed -i "s/versionCode 10000 + gitCommits/versionCode 10000 + ${{ env.BUILD_NUMBER }}/" $GITHUB_WORKSPACE/app/build.gradle
          
          echo "versionName 已设置为 ${{ env.VERSIONL }}"
          echo "versionCode 已设置为 10000 + ${{ env.BUILD_NUMBER }}"

      - name: Build With Gradle
        run: |
          echo "开始${{ env.product }}${{ env.type }}构建"
          chmod +x gradlew
          # Gradle 现在会读取修改后的 version.properties 来获取 versionName
          ./gradlew assemble${{ env.product }}Release

      - name: Move Missing Rules Files
        run: |
          echo "移动missing_rules.txt文件"
          mkdir -p ${{ github.workspace }}/mapping/
          for file in `ls ${{ github.workspace }}/app/build/outputs/mapping/*/missing_rules.txt`; do
            mv "$file" ${{ github.workspace }}/mapping/missing_rules.txt
          done

      - name: Upload Missing Rules File To Artifact
        uses: actions/upload-artifact@v4
        with:
          name: legado.${{ env.product }}.${{ env.type }}.mapping.missing_rules
          if-no-files-found: ignore
          path: ${{ github.workspace }}/mapping/missing_rules.txt

      - name: Check Build production
        run: |
          echo "查看 APK 输出目录"
          ls -R $GITHUB_WORKSPACE/app/build/outputs/apk/
          if ! ls $GITHUB_WORKSPACE/app/build/outputs/apk/*/*/*.apk 1> /dev/null 2>&1; then
            echo "Build production not found! Check gradle logs."
            exit 1
          fi

      - name: Upload universal APK
        uses: actions/upload-artifact@v4
        with:
          name: universal-apk
          path: app/build/outputs/apk/app/release/legado_app_*[0-9].apk

      - name: Upload arm64-v8a APK
        uses: actions/upload-artifact@v4
        with:
          name: arm64-v8a-apk
          path: app/build/outputs/apk/app/release/*arm64-v8a.apk

      - name: Upload armeabi-v7a APK
        uses: actions/upload-artifact@v4
        with:
          name: armeabi-v7a-apk
          path: app/build/outputs/apk/app/release/*armeabi-v7a.apk

      - name: Upload Mapping File To Artifact
        uses: actions/upload-artifact@v4
        with:
          name: legado.${{ env.product }}.${{ env.type }}.mapping
          if-no-files-found: ignore
          path: ${{ github.workspace }}/mapping/mapping.txt


  test_Branch:
    needs: [ prepare, build ]
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'pull_request' && github.actor == 'gedoor' }}
    steps:
      - uses: actions/checkout@v5
      - uses: actions/download-artifact@v5
        with:
          path: apk/
      - working-directory: apk/
        run: mv */*.apk . ;rm -rf */
      - name: Push To "test" Branch
        run: |
          cd $GITHUB_WORKSPACE/apk/
          git init
          git checkout -b test
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git remote add origin "https://${{ github.actor }}:${{ secrets.ACTIONS_TOKEN }}@github.com/${{ github.actor }}/release"
          git add *.apk
          git commit -m "${{ needs.prepare.outputs.versionL }}"
          git push -f -u origin test

  create_pre_release:
    needs: [ prepare, build ]
    if: |
      github.event_name == 'push' && 
      github.ref == 'refs/heads/main' && 
      needs.prepare.outputs.build_number > 0 &&
      success()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 获取所有 Commit 消息作为 Release Body
        id: get_commits
        run: |
          # 获取从上一个 tag 到当前 commit 之间的所有 commit 消息
          # 如果 latest_tag 为空，则从第一个 commit 开始获取
          
          LATEST_TAG="${{ needs.prepare.outputs.latest_tag }}"
          
          if [ -z "$LATEST_TAG" ]; then
            # 如果没有找到任何 tag，则从第一个 commit 开始
            COMMIT_LOG=$(git log --pretty=format:'* %s (%an)' --reverse)
          else
            # 从最近的 tag 到当前 HEAD
            # 使用 ^$LATEST_TAG 来排除 LATEST_TAG 本身的 commit
            COMMIT_LOG=$(git log $LATEST_TAG..HEAD --pretty=format:'* %s (%an)')
          fi
          
          # 检查是否获取到日志
          if [ -z "$COMMIT_LOG" ]; then
            RELEASE_BODY="本次发布无新增 Commit。"
          else
            RELEASE_BODY="# 本次更新内容\n\n$COMMIT_LOG"
          fi
          
          # 输出给下一步使用
          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name:
          创建 Pre-Release Tag ${{ needs.prepare.outputs.versionL }}
        # 创建一个 Tag，供下一轮计算版本号时使用
        run: |
          git tag v${{ needs.prepare.outputs.versionL }}
          git push origin v${{ needs.prepare.outputs.versionL }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 创建 Pre-Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Tag 名称：3.26.3-beta.1
          tag_name: ${{ needs.prepare.outputs.versionL }}
          # Release 标题：3.26.3-beta.1
          release_name: ${{ needs.prepare.outputs.versionL }}
          # Release 内容为所有 Commit 消息
          body: ${{ steps.get_commits.outputs.release_body }}
          draft: false
          # 标记为预发布版本
          prerelease: true

      - name: 下载所有 APK Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: '*-apk'
          path: artifacts
          merge-multiple: true

      - name: 上传 Release Assets
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: artifacts/*.apk
          # 重新命名上传的 APK 文件，使其包含版本号
          asset_name: legado-${{ needs.prepare.outputs.versionL }}.apk
          asset_content_type: application/zip