name: Test Build

on:
  push:
    branches:
      - main
    paths:
      - '**'
      # - '!**/assets/**'
      # - '!**.md'
      - '!**/ISSUE_TEMPLATE/**'
      - '!**/modules/web/**'
  pull_request:
    paths-ignore:
      - '**/modules/web/**'
  workflow_run:
    workflows: [Build Web]
    branches: [master]
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:

  prepare:
    runs-on: ubuntu-latest
    if: ${{ !startsWith(github.event.head_commit.message, 'Merge pull request') }}
    outputs:
      # versionL: 完整版本号，例如 3.26.3-beta.1
      versionL: ${{ steps.set-ver.outputs.full_version_name }}
      # version: 基础版本号，例如 3.26.3
      version: ${{ steps.set-ver.outputs.current_version }}
      # build_number: 增量构建号，例如 1
      build_number: ${{ steps.set-ver.outputs.build_number }}
      # latest_tag: 最近一个用于版本递增的 tag，例如 3.26.2-beta.5 (不带v前缀)
      latest_tag: ${{ steps.set-ver.outputs.last_tag }}
    steps:
      - uses: actions/checkout@v4
        with:
          # 确保拉取所有标签，用于版本号计算
          fetch-depth: 0

      - name: 计算版本号和构建号
        id: set-ver
        run: |
          PROPERTIES_FILE="./app/version.properties"
          if [[ ! -f "$PROPERTIES_FILE" ]]; then
          echo "错误：version.properties 文件不存在于 $PROPERTIES_FILE"
          exit 1
          fi
          # 确保获取到的版本号没有空格
          MAJOR=$(cat "$PROPERTIES_FILE" | grep 'VERSION_MAJOR' | cut -d'=' -f2 | tr -d '[:space:]')
          MINOR=$(cat "$PROPERTIES_FILE" | grep 'VERSION_MINOR' | cut -d'=' -f2 | tr -d '[:space:]')
          PATCH=$(cat "$PROPERTIES_FILE" | grep 'VERSION_PATCH' | cut -d'=' -f2 | tr -d '[:space:]')
          CURRENT_VERSION="$MAJOR.$MINOR.$PATCH"

          # 1. 找到仓库中最近创建的任意 TAG (无论是正式版还是测试版)，作为日志起点
          LAST_ANY_TAG=$(git tag --sort=-committerdate | head -n 1)
          
          # 2. 尝试获取匹配当前 CURRENT_VERSION 的上一个 TAG (用于版本号递增)
          if [[ "${{ github.event_name }}" == "push" && "${{ github.ref }}" == "refs/heads/main" ]]; then
          
              # 查找匹配当前 CURRENT_VERSION 的上一个 TAG (e.g., v3.26.3-beta.X)
              LAST_MATCHING_TAG_WITH_V=$(git tag --list "v$CURRENT_VERSION-beta.*" --sort=-committerdate | head -n 1)
              LAST_MATCHING_TAG="${LAST_MATCHING_TAG_WITH_V#v}" # 移除 'v'

              if [[ $LAST_MATCHING_TAG =~ [0-9]+\.[0-9]+\.[0-9]+-beta\.([0-9]+) ]]; then
                # 如果找到匹配当前 PATCH 版本的 beta 标签，则递增
                LAST_BUILD_NUM="${BASH_REMATCH[1]}"
                NEW_BUILD_NUM=$((LAST_BUILD_NUM + 1))
                LAST_TAG_FOR_LOG="$LAST_MATCHING_TAG"
                echo "版本 $CURRENT_VERSION 未变更，构建号自增：$LAST_BUILD_NUM -> $NEW_BUILD_NUM"
              else
                # 如果找不到匹配的标签 (PATCH 刚修改，或首次构建)，则重置为 1
                NEW_BUILD_NUM=1
                # 此时，日志应该从最近的 '非本次构建' 的 TAG 开始
                LAST_TAG_FOR_LOG="${LAST_ANY_TAG#v}"
                echo "版本 $CURRENT_VERSION 为新版本或首次构建，构建号重置为 $NEW_BUILD_NUM。日志将从 $LAST_TAG_FOR_LOG 开始。"
              fi
          else
              # 对于 PR 或其他分支，使用一个固定的构建号 0
              NEW_BUILD_NUM=0
              LAST_TAG_FOR_LOG="${LAST_ANY_TAG#v}"
              echo "非 main 分支推送，构建号设置为 $NEW_BUILD_NUM"
          fi
          
          # 3. 构造最终版本信息
          VERSION_SUFFIX_NAME="-beta.$NEW_BUILD_NUM"
          FULL_VERSION_NAME="${CURRENT_VERSION}${VERSION_SUFFIX_NAME}"
          
          # 4. 设置输出供后续作业使用
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "full_version_name=$FULL_VERSION_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$NEW_BUILD_NUM" >> $GITHUB_OUTPUT
          echo "last_tag=$LAST_TAG_FOR_LOG" >> $GITHUB_OUTPUT

  build:
    needs: prepare
    strategy:
      matrix:
        product: [ app ]
        type: [ release ]
      fail-fast: false
    runs-on: ubuntu-latest
    env:
      product: ${{ matrix.product }}
      type: ${{ matrix.type }}
      # 使用 prepare job 的输出
      VERSION: ${{ needs.prepare.outputs.version }}
      VERSIONL: ${{ needs.prepare.outputs.versionL }}
      BUILD_NUMBER: ${{ needs.prepare.outputs.build_number }}
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 0
      - name: Set up JDK 17
        uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: 17
      - name: Clear 18PlusList.txt
        run: |
          echo "清空18PlusList.txt"
          echo "">$GITHUB_WORKSPACE/app/src/main/assets/18PlusList.txt
      - name: Release Apk Sign
        run: |
          echo "${{ secrets.SIGNING_KEY }}" | base64 -d > $GITHUB_WORKSPACE/app/my-release-key.jks
          echo "RELEASE_STORE_FILE=my-release-key.jks" >> $GITHUB_WORKSPACE/gradle.properties
          echo "RELEASE_STORE_PASSWORD=${{ secrets.KEYSTORE_PASSWORD }}" >> $GITHUB_WORKSPACE/gradle.properties
          echo "RELEASE_KEY_ALIAS=${{ secrets.KEY_ALIAS }}" >> $GITHUB_WORKSPACE/gradle.properties
          echo "RELEASE_KEY_PASSWORD=${{ secrets.KEY_PASSWORD }}" >> $GITHUB_WORKSPACE/gradle.properties

      - name: Set up Gradle
        uses: gradle/actions/setup-gradle@v4

      - name: 统一版本号
        run: |
          # 1. 临时修改 version.properties 中的 VERSION_SUFFIX
          echo "VERSION_SUFFIX=-beta.${{ env.BUILD_NUMBER }}" >> ./app/version.properties

          # 2. 覆盖 build.gradle 中复杂的 versionCode 计算逻辑
          sed -i "s/versionCode 10000 + gitCommits/versionCode 10000 + ${{ env.BUILD_NUMBER }}/" $GITHUB_WORKSPACE/app/build.gradle

          echo "versionName 已设置为 ${{ env.VERSIONL }}"
          echo "versionCode 已设置为 10000 + ${{ env.BUILD_NUMBER }}"

      - name: Build With Gradle
        run: |
          echo "开始${{ env.product }}${{ env.type }}构建"
          chmod +x gradlew
          ./gradlew assemble${{ env.product }}Release

      - name: Move Missing Rules Files
        run: |
          echo "移动missing_rules.txt文件"
          MAPPING_DIR="${{ github.workspace }}/mapping"
          mkdir -p "$MAPPING_DIR"
          # 使用 find 代替 ls，避免参数列表过长
          find ${{ github.workspace }}/app/build/outputs/mapping/ -name "missing_rules.txt" -exec mv {} "$MAPPING_DIR/missing_rules.txt" \;

      - name: Upload Missing Rules File To Artifact
        uses: actions/upload-artifact@v4
        with:
          name: legado.${{ env.product }}.${{ env.type }}.mapping.missing_rules
          if-no-files-found: ignore
          path: ${{ github.workspace }}/mapping/missing_rules.txt

      - name: Check Build production
        run: |
          echo "检查 APK 输出目录"
          APK_PATH="$GITHUB_WORKSPACE/app/build/outputs/apk"
          # 检查是否有任何 APK 文件生成
          if [ -z "$(find "$APK_PATH" -name "*.apk" -print -quit)" ]; then
            echo "Build production not found! Check gradle logs."
            exit 1
          fi

      - name: Upload universal APK
        uses: actions/upload-artifact@v4
        with:
          name: universal-apk
          path: app/build/outputs/apk/app/release/legado_app_*[0-9].apk

      - name: Upload arm64-v8a APK
        uses: actions/upload-artifact@v4
        with:
          name: arm64-v8a-apk
          path: app/build/outputs/apk/app/release/*arm64-v8a.apk

      - name: Upload armeabi-v7a APK
        uses: actions/upload-artifact@v4
        with:
          name: armeabi-v7a-apk
          path: app/build/outputs/apk/app/release/*armeabi-v7a.apk

      - name: Upload Mapping File To Artifact
        uses: actions/upload-artifact@v4
        with:
          name: legado.${{ env.product }}.${{ env.type }}.mapping
          if-no-files-found: ignore
          path: ${{ github.workspace }}/mapping/mapping.txt


  test_Branch:
    needs: [ prepare, build ]
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'pull_request' && github.actor == 'gedoor' }}
    steps:
      - uses: actions/checkout@v5
      - uses: actions/download-artifact@v5
        with:
          path: apk/
      - working-directory: apk/
        run: |
          # 使用 find 安全地移动文件
          find . -type f -name "*.apk" -exec mv {} . \;
          # 清理子目录
          find . -type d -mindepth 1 -exec rm -rf {} +

      - name: Push To "test" Branch
        run: |
          cd $GITHUB_WORKSPACE/apk/
          git init
          git checkout -b test
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git remote add origin "https://${{ github.actor }}:${{ secrets.ACTIONS_TOKEN }}@github.com/${{ github.actor }}/release"
          git add *.apk
          git commit -m "${{ needs.prepare.outputs.versionL }}"
          git push -f -u origin test

  create_pre_release:
    needs: [ prepare, build ]
    if: |
      github.event_name == 'push' &&
      github.ref == 'refs/heads/main' &&
      needs.prepare.outputs.build_number > 0 &&
      success()
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 获取所有 Commit 消息作为 Release Body
        id: get_commits
        run: |
          LATEST_TAG="${{ needs.prepare.outputs.latest_tag }}"

          if [ -z "$LATEST_TAG" ]; then
            # 如果没有找到任何 tag，则从第一个 commit 开始获取所有日志
            COMMIT_LOG=$(git log --pretty=format:'* %s (%an)' --reverse)
          else
            # 从最近一个 Tag 到当前 HEAD 获取 Commit 记录
            COMMIT_LOG=$(git log v$LATEST_TAG..HEAD --pretty=format:'* %s (%an)')
          fi

          if [ -z "$COMMIT_LOG" ]; then
            RELEASE_BODY="本次发布无新增 Commit。"
          else
            RELEASE_BODY="# 本次更新内容\n\n$COMMIT_LOG"
          fi

          echo "release_body<<EOF" >> $GITHUB_OUTPUT
          echo "$RELEASE_BODY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: 创建 Pre-Release Tag
        run: |
          # 在 push tag 时加上 "v" 前缀
          git tag v${{ needs.prepare.outputs.versionL }}
          git push origin v${{ needs.prepare.outputs.versionL }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 创建 Pre-Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # Tag 名称：例如 3.26.3-beta.1
          tag_name: ${{ needs.prepare.outputs.versionL }}
          # Release 标题：例如 Pre-release 3.26.3-beta.1
          release_name: Pre-release ${{ needs.prepare.outputs.versionL }}
          # Release 内容为所有 Commit 消息
          body: ${{ steps.get_commits.outputs.release_body }}
          draft: false
          # 标记为预发布版本
          prerelease: true

      - name: 下载所有 APK Artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: '*-apk'
          path: artifacts
          merge-multiple: true

      - name: 上传 Release Assets
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.create_release.outputs.upload_url }}
          asset_path: artifacts/*.apk
          asset_name: legado-${{ needs.prepare.outputs.versionL }}.apk
          asset_content_type: application/zip